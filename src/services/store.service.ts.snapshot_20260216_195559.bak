
import { Injectable, signal, computed, effect, inject } from '@angular/core';
import { SupabaseService } from './supabase.service';
import { NotificationService } from './notification.service';

// --- Interfaces ---
export interface Category {
  id: string;
  name: string;
  slug: string;
  image: string;
}

export interface ProductVariant {
  size: string;
  color: string;
  stock: number;
}

export interface Product {
  id: string;
  name: string;
  categoryId: string;
  categoryName?: string;
  gender: 'girl' | 'boy' | 'unisex';
  price: number;
  originalPrice: number;
  discount: number;
  image: string;
  gallery: string[];
  colorImages?: { color: string; image: string }[]; 
  video?: string; 
  sizes: string[];
  colors: { name: string; hex: string }[];
  stock: number; 
  variants?: ProductVariant[]; 
  rating: number;
  reviews: number;
  isNew: boolean;
  isBestSeller: boolean;
  description?: string;
}

export interface Review {
  id: string;
  productId: string;
  user: string;
  date: string;
  rating: number;
  comment: string;
  image?: string;
}

export interface Banner {
  id: string;
  location: 'home-hero' | 'home-mid' | 'catalog-sidebar' | 'catalog-top';
  image: string;
  title?: string;
  subtitle?: string; 
  link: string;
  description?: string;
  badgeText?: string;
  endDate?: string; 
  active?: boolean;
}

export interface CartItem extends Product {
  selectedSize: string;
  selectedColor: string;
  quantity: number;
}

export interface OrderAddress {
  cep: string;
  street: string;
  number: string;
  city: string;
}

export interface Order {
  id: string;
  date: string;
  status: 'pending' | 'paid' | 'shipped' | 'delivered' | 'cancelled';
  total: number;
  items: CartItem[];
  customerName: string;
  customerCpf?: string;     
  customerPhone?: string;   
  shippingAddress?: OrderAddress; 
  paymentMethod: string;
  userEmail?: string; 
  isGift?: boolean; 
}

export interface User {
  id: string;
  name: string;
  email?: string;
  phone?: string;
  role: 'admin' | 'customer';
}

export interface Toast {
  message: string;
  type: 'success' | 'error' | 'info';
  id: number;
}

export interface Coupon {
  id: string;
  code: string;
  type: 'percent' | 'fixed' | 'shipping';
  value: number;
  minPurchase: number;
  active: boolean;
  description?: string; 
}

export interface ContactMessage {
  id: string;
  name: string;
  email: string;
  subject: string;
  message: string;
  date: string;
  read: boolean;
}

export interface StockAlert {
  id: string;
  productName: string;
  email: string;
  date: string;
}

export interface Institutional {
  logoUrl: string; 
  aboutTitle: string;
  aboutText: string;
  aboutImage: string;
  privacyText: string;
  termsText: string;
  exchangePolicyText: string;
  whatsapp: string;
  email: string;
  address: string;
  instagramUrl: string;
  consentTitle: string;
  consentText: string;
  mercadoPagoPublicKey?: string;
  mercadoPagoAccessToken?: string;
  pixKey?: string; 
  iconVersion?: number;
  notificationsEnabled?: boolean;
  defaultDeepLink?: string;
}

// NEW: Instagram Post Interface for Admin Management
export interface InstagramPost {
  id: string;
  image_url: string;
  likes: number;
  link?: string;
}

// --- MOCK DATA ---
const DEFAULT_INSTITUTIONAL: Institutional = {
  logoUrl: '', 
  aboutTitle: 'Quem Somos',
  aboutText: 'A YARA Kids nasceu do sonho de vestir crianÃ§as com a pureza e a alegria da infÃ¢ncia. Fundada em RedenÃ§Ã£o/PA, nossa loja busca trazer o que hÃ¡ de mais moderno e confortÃ¡vel na moda infantil.\n\nAcreditamos que roupa de crianÃ§a tem que ser alegre, colorida e permitir o movimento. Por isso, selecionamos cada peÃ§a com muito carinho.',
  aboutImage: 'https://images.unsplash.com/photo-1621452773781-0f992ee03591?w=800&fit=crop',
  privacyText: '1. DADOS COLETADOS\nColetamos: nome, email, CPF, endereÃ§o, telefone para processamento de pedidos.\n\n2. USO DOS DADOS\nUsamos seus dados para processar pedidos e enviar notificaÃ§Ãµes.\n\n3. COMPARTILHAMENTO\nNÃ£o vendemos seus dados. Compartilhamos apenas com transportadoras.',
  termsText: '1. ACEITAÃ‡ÃƒO\nAo usar o site YARA Kids, vocÃª concorda com estes termos.\n\n2. PRODUTOS\nAs imagens sÃ£o ilustrativas. Cores podem variar.\n\n3. PREÃ‡OS\nSujeitos a alteraÃ§Ã£o sem aviso prÃ©vio.',
  exchangePolicyText: 'VocÃª tem 7 dias para devoluÃ§Ã£o por arrependimento e 30 dias para troca por defeito ou tamanho. O produto deve estar com a etiqueta.',
  whatsapp: '(94) 99133-4401',
  email: 'contato@yarakids.com.br',
  address: 'RedenÃ§Ã£o, PA â€” Brasil',
  instagramUrl: 'https://instagram.com/yarakids_moda_infatil',
  consentTitle: 'Sua Privacidade Ã© Importante ðŸ”’',
  consentText: 'Para garantir uma experiÃªncia segura e salvar suas compras, precisamos que vocÃª concorde com nossos termos. Ao continuar, vocÃª aceita nossa PolÃ­tica de Privacidade e Termos de Uso.',
  mercadoPagoPublicKey: '',
  mercadoPagoAccessToken: '',
  pixKey: '00.000.000/0001-00'
};

const MOCK_CATEGORIES: Category[] = [
  { id: 'cat-1', name: 'Vestidos', slug: 'vestidos', image: 'https://images.unsplash.com/photo-1518831959646-742c3a14ebf7?w=600&q=80' },
  { id: 'cat-2', name: 'Conjuntos', slug: 'conjuntos', image: 'https://images.unsplash.com/photo-1519238263496-6361937a42d8?w=600&q=80' },
  { id: 'cat-3', name: 'AcessÃ³rios', slug: 'acessorios', image: 'https://images.unsplash.com/photo-1617331530973-2dc7463f27a6?w=600&q=80' },
  { id: 'cat-4', name: 'Maternidade', slug: 'maternidade', image: 'https://images.unsplash.com/photo-1555252333-9f8e92e65df9?w=600&q=80' }
];

const createVariants = (sizes: string[], colors: string[], stockPerVariant: number) => {
  const variants: ProductVariant[] = [];
  sizes.forEach(s => {
    colors.forEach(c => {
      variants.push({ size: s, color: c, stock: stockPerVariant });
    });
  });
  return variants;
};

const MOCK_PRODUCTS: Product[] = [
  {
    id: 'demo-1',
    name: 'Vestido Floral Encantado',
    categoryId: 'cat-1',
    categoryName: 'Vestidos',
    gender: 'girl',
    price: 89.9,
    originalPrice: 119.9,
    discount: 25,
    image: 'https://images.unsplash.com/photo-1518831959646-742c3a14ebf7?w=800&q=80',
    gallery: [
      'https://images.unsplash.com/photo-1518831959646-742c3a14ebf7?w=800&q=80',
      'https://images.unsplash.com/photo-1621452773781-0f992ee03591?w=800&q=80'
    ],
    colorImages: [
        { color: 'Rosa', image: 'https://images.unsplash.com/photo-1621452773781-0f992ee03591?w=800&q=80' }
    ],
    video: '', 
    sizes: ['4', '6', '8', '10'],
    colors: [{ name: 'Rosa', hex: '#FF69B4' }],
    stock: 20,
    variants: createVariants(['4', '6', '8', '10'], ['Rosa'], 5),
    rating: 4.9,
    reviews: 124,
    isNew: true,
    isBestSeller: true,
    description: 'Vestido perfeito para festas de verÃ£o, tecido leve e respirÃ¡vel com estampa floral delicada.'
  },
  {
    id: 'demo-2',
    name: 'Conjunto Dino Radical',
    categoryId: 'cat-2',
    categoryName: 'Conjuntos',
    gender: 'boy',
    price: 69.9,
    originalPrice: 79.9,
    discount: 12,
    image: 'https://images.unsplash.com/photo-1632187752674-3232049e7b23?w=800&q=80',
    gallery: ['https://images.unsplash.com/photo-1632187752674-3232049e7b23?w=800&q=80'],
    sizes: ['2', '4', '6'],
    colors: [{ name: 'Verde', hex: '#4ADE80' }, { name: 'Azul', hex: '#60A5FA' }],
    stock: 30,
    variants: createVariants(['2', '4', '6'], ['Verde', 'Azul'], 5),
    rating: 4.8,
    reviews: 56,
    isNew: true,
    isBestSeller: false,
    description: 'Conjunto confortÃ¡vel de algodÃ£o para os pequenos exploradores brincarem Ã  vontade.'
  }
];

const MOCK_REVIEWS: Review[] = [
  { id: 'r1', productId: 'demo-1', user: 'Ana Paula', date: '12/02/2026', rating: 5, comment: 'Amei o tecido! Minha filha nÃ£o quer tirar mais.', image: 'https://images.unsplash.com/photo-1596870230751-ebdfce98ec42?w=100&q=80' },
  { id: 'r2', productId: 'demo-1', user: 'Marcos Silva', date: '10/02/2026', rating: 4, comment: 'Chegou super rÃ¡pido, o tamanho ficou perfeito.' }
];

const FUTURE_DATE = new Date();
FUTURE_DATE.setHours(FUTURE_DATE.getHours() + 48);

const MOCK_BANNERS: Banner[] = [
  {
    id: 'b1',
    location: 'home-hero',
    image: 'https://images.unsplash.com/photo-1603569283847-aa295f0d016a?w=1800&q=85',
    title: 'Nova ColeÃ§Ã£o',
    subtitle: 'Estilo e conforto',
    link: '/catalogo'
  },
  {
    id: 'b2',
    location: 'home-mid',
    image: 'https://images.unsplash.com/photo-1604467794349-0b74285de7e7?w=1200&q=80',
    title: 'Looks Completos',
    subtitle: 'Praticidade para mamÃ£es',
    description: 'Aproveite descontos exclusivos. Vestidos e conjuntos dignos de princesa!',
    badgeText: 'Tempo Limitado',
    endDate: FUTURE_DATE.toISOString(),
    link: '/catalogo?cat=conjuntos'
  }
];

const MOCK_COUPONS: Coupon[] = [
  { id: '1', code: 'BEMVINDA10', type: 'percent', value: 10, minPurchase: 0, active: true, description: '10% de desconto para novos clientes' },
  { id: '2', code: 'YARA20', type: 'fixed', value: 20, minPurchase: 100, active: true, description: 'R$ 20 OFF em compras acima de R$ 100' },
  { id: '3', code: 'FRETEGRATIS', type: 'shipping', value: 0, minPurchase: 50, active: true, description: 'Frete GrÃ¡tis para todo Brasil' }
];

const TODAY_STR = new Date().toLocaleDateString('pt-BR'); // Format: dd/mm/yyyy

const MOCK_ORDERS: Order[] = [
  { 
    id: '9821', date: TODAY_STR, status: 'paid', total: 179.8, customerName: 'Ana Clara', 
    items: [
        { ...MOCK_PRODUCTS[0], selectedSize: '6', selectedColor: 'Rosa', quantity: 2 } as CartItem
    ], 
    paymentMethod: 'pix',
    customerCpf: '123.456.789-00', customerPhone: '(94) 99999-9999', shippingAddress: { cep: '68550-000', street: 'Av. Brasil', number: '120', city: 'RedenÃ§Ã£o - PA' } 
  },
  { 
    id: '9820', date: TODAY_STR, status: 'pending', total: 69.9, customerName: 'Bruno Silva', 
    items: [
        { ...MOCK_PRODUCTS[1], selectedSize: '4', selectedColor: 'Verde', quantity: 1 } as CartItem
    ], 
    paymentMethod: 'card',
    customerCpf: '987.654.321-11', customerPhone: '(11) 98888-8888', shippingAddress: { cep: '01001-000', street: 'PraÃ§a da SÃ©', number: '15', city: 'SÃ£o Paulo - SP' }
  }
];

// Mock Instagram Posts (Fallback)
const MOCK_INSTAGRAM: InstagramPost[] = [
    { id: '1', image_url: 'https://images.unsplash.com/photo-1596870230751-ebdfce98ec42?w=400&q=80', likes: 124 },
    { id: '2', image_url: 'https://images.unsplash.com/photo-1621452773781-0f992ee03591?w=400&q=80', likes: 256 },
    { id: '3', image_url: 'https://images.unsplash.com/photo-1622290291468-a28f7a7dc6a8?w=400&q=80', likes: 89 },
    { id: '4', image_url: 'https://images.unsplash.com/photo-1503919545889-aef636e10ad4?w=400&q=80', likes: 412 },
    { id: 5, image: 'https://images.unsplash.com/photo-1603569283847-aa295f0d016a?w=400&q=80', likes: 132 },
    { id: 6, image: 'https://images.unsplash.com/photo-1471286174890-9c808743a753?w=400&q=80', likes: 98 },
] as any;

@Injectable({
  providedIn: 'root'
})
export class StoreService {
  supabase = inject(SupabaseService);
  notifications = inject(NotificationService);

  // --- State ---
  mode = signal<'visual' | 'real'>('visual');
  theme = signal<'light' | 'dark'>('light');
  animationsEnabled = signal<boolean>(true); 
  
  // Data Signals
  categories = signal<Category[]>([]);
  products = signal<Product[]>([]);
  banners = signal<Banner[]>([]);
  orders = signal<Order[]>([]);
  reviews = signal<Review[]>([]); 
  cart = signal<CartItem[]>([]);
  user = signal<User | null>(null);
  favorites = signal<string[]>([]);
  coupons = signal<Coupon[]>([]);
  institutional = signal<Institutional>(DEFAULT_INSTITUTIONAL);
  instagramPosts = signal<InstagramPost[]>([]); // New Signal
  
  // Admin Inbox Signals
  contactMessages = signal<ContactMessage[]>([]);
  stockAlerts = signal<StockAlert[]>([]);
  
  // New: Privacy & Terms State
  termsAccepted = signal<boolean>(false);

  // Cart Logic
  appliedCoupon = signal<Coupon | null>(null);
  isGiftWrapped = signal<boolean>(false); 
  giftWrapFee = 5; 
  
  recentProducts = signal<Product[]>([]);

  // UI State
  isCartOpen = signal<boolean>(false);
  showWelcomePopup = signal<boolean>(false);
  
  toasts = signal<Toast[]>([]);
  private authSyncInitialized = false;
  private settingsRealtimeInitialized = false;

  // --- Computed ---
  cartTotal = computed(() => Math.max(0, this.cart().reduce((acc, item) => acc + (item.price * item.quantity), 0)));
  cartCount = computed(() => Math.max(0, this.cart().reduce((acc, item) => acc + item.quantity, 0)));
  
  discountAmount = computed(() => {
    const coupon = this.appliedCoupon();
    const total = this.cartTotal();
    if (!coupon) return 0;
    
    if (total < coupon.minPurchase) return 0;
    
    if (coupon.type === 'percent') return total * (coupon.value / 100);
    if (coupon.type === 'fixed') return Math.min(total, coupon.value);
    return 0; 
  });

  finalPrice = computed(() => {
    const base = this.cartTotal() - this.discountAmount();
    const gift = this.isGiftWrapped() ? this.giftWrapFee : 0;
    return Math.max(0, base + gift);
  });

  dashboardStats = computed(() => {
    const currentOrders = this.orders();
    const sales = currentOrders.filter(o => o.status !== 'cancelled').reduce((acc, o) => acc + o.total, 0);
    const pending = currentOrders.filter(o => o.status === 'pending').length;
    
    let labels: string[] = [];
    let data: number[] = [];

    if (this.mode() === 'visual') {
        const today = new Date();
        for(let i = 6; i >= 0; i--) {
            const d = new Date(today);
            d.setDate(today.getDate() - i);
            labels.push(d.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' }));
        }
        data = [450, 380, 620, 890, 340, 760, sales]; 
    } else {
        const salesMap = new Map<string, number>();
        const today = new Date();
        
        for(let i = 6; i >= 0; i--) {
            const d = new Date(today);
            d.setDate(today.getDate() - i);
            const fullDateStr = d.toLocaleDateString('pt-BR'); 
            const shortDateStr = d.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' }); 
            
            salesMap.set(fullDateStr, 0);
            labels.push(shortDateStr);
        }

        currentOrders.forEach(order => {
            if(order.status !== 'cancelled') {
                if (salesMap.has(order.date)) {
                    salesMap.set(order.date, (salesMap.get(order.date) || 0) + order.total);
                }
            }
        });

        data = Array.from(salesMap.values());
    }
    
    return {
      sales: sales,
      orders: currentOrders.length,
      pending: pending,
      chart: { labels, data }
    };
  });

  constructor() {
    this.init();
    
    // Effect to update favicon whenever logo changes
    effect(() => {
        const logo = this.institutional().logoUrl;
        if (logo) {
            this.updateFavicon(logo);
        }
    });
  }

  private init() {
    // Theme
    const savedTheme = localStorage.getItem('yarakids_theme') as 'light' | 'dark';
    if (savedTheme) {
      this.theme.set(savedTheme);
    } else if (globalThis.matchMedia('(prefers-color-scheme: dark)').matches) {
      this.theme.set('dark');
    }

    const savedAnim = localStorage.getItem('yarakids_animations');
    if (savedAnim === 'false') {
        this.animationsEnabled.set(false);
    }

    const savedTerms = localStorage.getItem('yarakids_terms_accepted');
    if (savedTerms === 'true') {
        this.termsAccepted.set(true);
    }
    
    this.initGlobalMode();

    // Persist Effects
    effect(() => localStorage.setItem('yarakids_cart', JSON.stringify(this.cart())));
    effect(() => localStorage.setItem('yarakids_favorites', JSON.stringify(this.favorites())));
    effect(() => {
        if (this.animationsEnabled()) {
            document.body.classList.remove('reduce-motion');
            localStorage.setItem('yarakids_animations', 'true');
        } else {
            document.body.classList.add('reduce-motion');
            localStorage.setItem('yarakids_animations', 'false');
        }
    });
    
    effect(() => {
      const t = this.theme();
      localStorage.setItem('yarakids_theme', t);
      if (t === 'dark') {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
    });
  }

  private async initGlobalMode() {
    try {
      const { data } = await this.supabase.supabase.from('site_settings').select('data').single();
      const serverMode = data?.data?.appMode;
      if (serverMode === 'visual' || serverMode === 'real') {
        this.mode.set(serverMode);
      }
    } catch (e) {
      console.error('Erro ao carregar modo global', e);
    }

    if (this.mode() === 'real') {
      this.initAuthSync();
    }

    this.initSettingsRealtime();
    this.loadData();
  }

  private initAuthSync() {
    if (this.authSyncInitialized) return;
    this.authSyncInitialized = true;

    this.supabase.supabase.auth.getUser().then(({ data }) => {
      if (!data.user) return;
      const isAdmin = data.user.email === 'admin@yarakids.com.br';
      this.user.set({
        id: data.user.id,
        email: data.user.email,
        phone: data.user.phone,
        name: data.user.user_metadata?.['name'] || data.user.email?.split('@')[0] || data.user.phone || 'Cliente',
        role: isAdmin ? 'admin' : 'customer'
      });
      this.notifications.initialize({ id: data.user.id, email: data.user.email || undefined });
    });

    this.supabase.supabase.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_IN' && session?.user) {
        const isAdmin = session.user.email === 'admin@yarakids.com.br';
        this.user.set({
          id: session.user.id,
          email: session.user.email,
          phone: session.user.phone,
          name: session.user.user_metadata?.['full_name'] || session.user.email?.split('@')[0] || session.user.phone || 'Cliente',
          role: isAdmin ? 'admin' : 'customer'
        });
        this.notifications.initialize({ id: session.user.id, email: session.user.email || undefined });
        this.loadData();
      } else if (event === 'SIGNED_OUT') {
        if (session?.user?.id) {
          this.notifications.deactivateUserSubscriptions(session.user.id);
        }
        this.user.set(null);
      }
    });
  }

  private initSettingsRealtime() {
    if (this.settingsRealtimeInitialized) return;
    this.settingsRealtimeInitialized = true;

    this.supabase.supabase
      .channel('settings-global-realtime')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'site_settings' }, () => this.loadRealSettings())
      .subscribe();
  }

  // --- GLOBAL ICON / IDENTITY MANAGER ---
  private updateFavicon(url: string) {
    const icon = document.getElementById('appIcon') as HTMLLinkElement;
    const appleIcon = document.getElementById('appAppleIcon') as HTMLLinkElement;
    
    if (icon) icon.href = url;
    if (appleIcon) appleIcon.href = url;
    this.updateDynamicManifest(url, this.institutional().iconVersion || Date.now());
  }

  private updateDynamicManifest(iconUrl: string, iconVersion: number) {
    const manifest = {
      name: 'YARA Kids - Moda Infantil',
      short_name: 'YARA Kids',
      start_url: '/',
      display: 'standalone',
      background_color: '#FFF0F5',
      theme_color: '#FF69B4',
      orientation: 'portrait-primary',
      scope: '/',
      icons: [
        { src: `${iconUrl}?v=${iconVersion}`, sizes: '192x192', type: 'image/png' },
        { src: `${iconUrl}?v=${iconVersion}`, sizes: '512x512', type: 'image/png' },
        { src: `${iconUrl}?v=${iconVersion}`, sizes: '192x192', type: 'image/png', purpose: 'maskable' }
      ]
    };

    const blob = new Blob([JSON.stringify(manifest)], { type: 'application/manifest+json' });
    const url = URL.createObjectURL(blob);
    const existing = document.querySelector<HTMLLinkElement>('link[rel="manifest"]');
    if (existing) {
      existing.href = url;
    }
  }

  acceptTerms() {
    this.termsAccepted.set(true);
    localStorage.setItem('yarakids_terms_accepted', 'true');
  }

  toggleAnimations() {
      this.animationsEnabled.update(v => !v);
      const msg = this.animationsEnabled() ? 'AnimaÃ§Ãµes ativadas!' : 'Modo desempenho ativado (sem animaÃ§Ãµes)';
      this.showToast(msg, 'info');
  }

  async setMode(newMode: 'visual' | 'real') {
    if (this.mode() === newMode) return;
    
    const previousMode = this.mode();
    this.mode.set(newMode);

    const persisted = await this.persistGlobalMode(newMode);
    if (!persisted) {
      this.mode.set(previousMode);
      this.showToast('Erro ao salvar modo global no servidor', 'error');
      return;
    }

    if (newMode === 'real') {
      this.initAuthSync();
    }

    this.cart.set([]); 
    this.appliedCoupon.set(null); 
    this.isGiftWrapped.set(false);
    await this.loadData();
    this.showToast(`Modo ${newMode === 'visual' ? 'Visual' : 'Real'} ativado!`, 'success');
  }

  private async persistGlobalMode(mode: 'visual' | 'real'): Promise<boolean> {
    try {
      const { data: existing } = await this.supabase.supabase.from('site_settings').select('id,data').single();
      const currentData = existing?.data ?? {};
      const nextData = { ...currentData, appMode: mode };

      if (existing?.id) {
        await this.supabase.supabase.from('site_settings').update({ data: nextData }).eq('id', existing.id);
      } else {
        await this.supabase.supabase.from('site_settings').insert({ data: nextData });
      }

      return true;
    } catch (e) {
      console.error('Erro ao persistir modo global', e);
      return false;
    }
  }

  toggleTheme() {
    this.theme.update(t => t === 'light' ? 'dark' : 'light');
  }

  toggleGiftWrap() {
    this.isGiftWrapped.update(v => !v);
  }

  private async loadData() {
    if (this.mode() === 'visual') {
      this.loadVisualData();
      return;
    }

    await this.loadRealData();
  }

  private loadVisualData() {
    this.categories.set(MOCK_CATEGORIES);
    this.products.set(MOCK_PRODUCTS);
    this.banners.set(MOCK_BANNERS);
    this.orders.set(MOCK_ORDERS);
    this.reviews.set(MOCK_REVIEWS);
    this.coupons.set(MOCK_COUPONS);
    this.instagramPosts.set(MOCK_INSTAGRAM);
  }

  private async loadRealData() {
    await this.loadRealSettings();
    await this.loadRealInstagram();
    await this.loadRealCatalog();
    await this.loadRealUserData();
  }

  private async loadRealSettings() {
    try {
      const { data } = await this.supabase.supabase.from('site_settings').select('data').single();
      if (data?.data) {
        const merged = {
          ...DEFAULT_INSTITUTIONAL,
          ...data.data,
          logoUrl: data.data?.branding?.logoUrl || data.data?.logoUrl || DEFAULT_INSTITUTIONAL.logoUrl,
          iconVersion: data.data?.branding?.iconVersion || data.data?.iconVersion || Date.now(),
          notificationsEnabled: data.data?.notifications?.enabled ?? true,
          defaultDeepLink: data.data?.notifications?.defaultDeepLink || '/'
        };
        this.institutional.set(merged);
      }
    } catch (e) {
      console.error('Erro settings', e);
    }
  }

  private async loadRealInstagram() {
    try {
      const posts = await this.supabase.getAll('instagram_posts');
      if (posts && posts.length > 0) {
        this.instagramPosts.set(posts);
      } else {
        this.instagramPosts.set(MOCK_INSTAGRAM);
      }
    } catch (e) {
      console.error('Erro insta', e);
      this.instagramPosts.set(MOCK_INSTAGRAM);
    }
  }

  private async loadRealCatalog() {
    try {
      const cats = await this.supabase.getAll('categories');
      this.categories.set(cats || []);
    } catch (e) {
      console.error('Erro ao carregar categorias', e);
    }

    try {
      const prods = await this.supabase.getAll('products');
      this.products.set(prods || []);
    } catch (e) {
      console.error('Erro ao carregar produtos', e);
    }
  }

  private async loadRealUserData() {
    const user = this.user();
    if (!user) return;

    try {
      const orders = await this.supabase.getAll('orders');
      this.orders.set(orders || []);
    } catch (e) {
      console.error('Erro ao carregar pedidos', e);
    }

    if (user.role !== 'admin') return;

    try {
      const msgs = await this.supabase.getAll('contact_messages');
      this.contactMessages.set(msgs || []);
      const alerts = await this.supabase.getAll('stock_alerts');
      this.stockAlerts.set(alerts || []);
    } catch (e) {
      console.error('Erro ao carregar mensagens', e);
    }
  }

  // --- Settings Persistence ---
  async updateInstitutional(data: Institutional) {
    this.institutional.set(data);
    
    if (this.mode() === 'real') {
        try {
            // Check if settings row exists
            const { data: existing } = await this.supabase.supabase.from('site_settings').select('id,data').single();
            const currentData = existing?.data ?? {};
            const iconVersion = Date.now();
            const nextData = {
              ...currentData,
              ...data,
              branding: {
                ...(currentData?.branding ? currentData.branding : undefined),
                logoUrl: data.logoUrl,
                iconVersion
              },
              notifications: {
                ...(currentData?.notifications ? currentData.notifications : undefined),
                enabled: data.notificationsEnabled ?? true,
                defaultDeepLink: data.defaultDeepLink || '/'
              }
            };
            
            if (existing) {
                await this.supabase.supabase.from('site_settings').update({ data: nextData }).eq('id', existing.id);
            } else {
                await this.supabase.supabase.from('site_settings').insert({ data: nextData });
            }
            this.showToast('ConfiguraÃ§Ãµes salvas no servidor!', 'success');
        } catch (e) {
            console.error('Erro ao salvar settings', e);
            this.showToast('Erro ao salvar no banco de dados', 'error');
        }
    } else {
        this.showToast('ConfiguraÃ§Ãµes salvas (Modo Visual)', 'success');
    }
  }

  // --- Instagram Management (Admin) ---
  async addInstagramPost(imageUrl: string) {
      const newPost = { id: 'insta-'+Date.now(), image_url: imageUrl, likes: 0, link: '' };
      
      if (this.mode() === 'real') {
          // Remove ID generated by client to let DB generate UUID if configured, or use UUID lib
          // For simplicity we send specific payload
          const { error } = await this.supabase.supabase.from('instagram_posts').insert({ image_url: imageUrl, likes: 0 });
          if(!error) {
              this.loadData(); // Reload to get real ID
              this.showToast('Post adicionado ao feed!', 'success');
          }
      } else {
          this.instagramPosts.update(p => [newPost, ...p]);
          this.showToast('Post adicionado (Visual)', 'success');
      }
  }

  async deleteInstagramPost(id: string) {
      if (this.mode() === 'real') {
          await this.supabase.delete('instagram_posts', id);
          this.instagramPosts.update(p => p.filter(x => x.id !== id));
      } else {
          this.instagramPosts.update(p => p.filter(x => x.id !== id));
      }
      this.showToast('Post removido', 'info');
  }

  // --- Actions for Messages & Alerts ---
  async sendContactMessage(data: { name: string, email: string, subject: string, message: string }) {
    const msg: ContactMessage = {
      id: 'msg-' + Date.now(),
      ...data,
      date: new Date().toLocaleDateString('pt-BR'),
      read: false
    };

    if (this.mode() === 'real') {
      try {
        await this.supabase.insert('contact_messages', msg);
      } catch (e) { console.error(e); }
    } else {
      this.contactMessages.update(m => [msg, ...m]);
    }
    
    this.showToast('Mensagem enviada! Em breve retornaremos.', 'success');
    if (this.mode() === 'real') {
      await this.notifications.queueEvent('contact_message_created', {
        name: msg.name,
        email: msg.email,
        subject: msg.subject
      }, this.user()?.id);
    }
  }

  async createStockAlert(data: { productName: string, email: string }) {
    const alert: StockAlert = {
      id: 'alert-' + Date.now(),
      ...data,
      date: new Date().toLocaleDateString('pt-BR')
    };

    if (this.mode() === 'real') {
      try {
        await this.supabase.insert('stock_alerts', alert);
      } catch (e) { console.error(e); }
    } else {
      this.stockAlerts.update(a => [alert, ...a]);
    }
    
    this.showToast('Alerta criado! Avisaremos quando chegar.', 'success');
    if (this.mode() === 'real') {
      await this.notifications.queueEvent('stock_alert_created', {
        productName: alert.productName,
        email: alert.email
      }, this.user()?.id);
    }
  }

  // --- External API Actions (Simulated Backend) ---
  
  async fetchAddressByCep(cep: string): Promise<any> {
    try {
      const cleanCep = cep.replaceAll(/\D/g, '');
      if (cleanCep.length !== 8) return null;
      
      const response = await fetch(`https://viacep.com.br/ws/${cleanCep}/json/`);
      const data = await response.json();
      
      if (data.erro) return null;
      
      return {
        address: data.logradouro,
        city: `${data.localidade} - ${data.uf}`,
        neighborhood: data.bairro
      };
    } catch (error) {
      console.error('CEP Error:', error);
      return null;
    }
  }

  async verifyAdminPassword(password: string): Promise<boolean> {
      await new Promise(resolve => setTimeout(resolve, 800));
      return password === 'YaraAdmin@2026!';
  }

  // --- Order Actions ---
  async createOrder(data: { 
    customer: string, 
    payment: string, 
    cpf?: string, 
    phone?: string, 
    address?: OrderAddress 
  }) {
    const newOrder = this.buildOrder(data);
    this.orders.update(o => [newOrder, ...o]);

    await this.persistOrder(newOrder);
    this.applyOrderStock(newOrder);

    this.clearCart();
    this.showToast('Pedido realizado com sucesso!', 'success');
    if (this.mode() === 'real') {
      await this.notifications.queueEvent('order_created', {
        orderId: newOrder.id,
        total: newOrder.total,
        customerName: newOrder.customerName
      }, this.user()?.id);
    }
    return newOrder;
  }

  private buildOrder(data: { customer: string; payment: string; cpf?: string; phone?: string; address?: OrderAddress }): Order {
    const currentUser = this.user();
    return {
      id: Math.floor(10000 + Math.random() * 90000).toString(),
      date: new Date().toLocaleDateString('pt-BR'),
      status: 'pending',
      total: this.finalPrice(),
      items: [...this.cart()],
      customerName: data.customer,
      paymentMethod: data.payment,
      userEmail: currentUser ? currentUser.email : undefined,
      customerCpf: data.cpf,
      customerPhone: data.phone,
      shippingAddress: data.address,
      isGift: this.isGiftWrapped()
    };
  }

  private async persistOrder(order: Order) {
    if (this.mode() !== 'real') return;

    try {
      await this.supabase.insert('orders', order);
    } catch (e) {
      console.error('Erro ao salvar pedido no Supabase', e);
      this.showToast('Erro ao salvar pedido no servidor', 'error');
    }
  }

  private applyOrderStock(order: Order) {
    this.products.update(prods => prods.map(p => this.applyProductStockDelta(p, order)));
  }

  private applyProductStockDelta(product: Product, order: Order): Product {
    const itemsInOrder = order.items.filter(i => i.id === product.id);
    if (itemsInOrder.length === 0) return product;

    const updatedProduct: Product = { ...product };
    for (const item of itemsInOrder) {
      updatedProduct.stock = Math.max(0, updatedProduct.stock - item.quantity);
      if (updatedProduct.variants) {
        updatedProduct.variants = updatedProduct.variants.map(v => {
          if (v.size === item.selectedSize && v.color === item.selectedColor) {
            return { ...v, stock: Math.max(0, v.stock - item.quantity) };
          }
          return v;
        });
      }
    }

    if (this.mode() === 'real') {
      this.supabase.update('products', product.id, { stock: updatedProduct.stock, variants: updatedProduct.variants });
    }

    return updatedProduct;
  }

  // --- Auth Actions ---
  
  async login(email: string, password?: string) {
    if (this.mode() === 'real') {
        if (!password) {
            this.showToast('Senha Ã© obrigatÃ³ria!', 'error');
            return false;
        }
        try {
            const { error } = await this.supabase.supabase.auth.signInWithPassword({ email, password });
            if (error) throw error;
            return true;
        } catch (e: any) {
            this.showToast('Erro no login: ' + e.message, 'error');
            return false;
        }
    } else {
        const newUser: User = {
          id: 'u-' + Date.now(),
          name: email.split('@')[0],
          email: email,
          role: email.includes('admin') ? 'admin' : 'customer'
        };
        this.user.set(newUser);
        this.showToast(`Bem-vindo, ${newUser.name}!`, 'success');
        return true;
    }
  }

  async loginWithGoogle() {
    if (this.mode() === 'real') {
        try {
            const { error } = await this.supabase.supabase.auth.signInWithOAuth({
              provider: 'google',
              options: {
                redirectTo: globalThis.location.origin
              }
            });
            if (error) throw error;
        } catch (e: any) {
            this.showToast('Erro Google Auth: ' + e.message, 'error');
        }
    } else {
        setTimeout(() => {
            const newUser: User = {
                id: 'u-google-' + Date.now(),
                name: 'Usuario Google',
                email: 'usuario.google@gmail.com',
                role: 'customer'
            };
            this.user.set(newUser);
            this.showToast('Login com Google simulado!', 'success');
        }, 1000);
    }
  }

  async register(email: string, password?: string, name?: string) {
    if (this.mode() === 'real') {
      if (!password) {
        this.showToast('Senha Ã© obrigatÃ³ria para cadastro.', 'error');
        return false;
      }
      try {
        const { error } = await this.supabase.supabase.auth.signUp({
          email,
          password,
          options: {
            data: { name: name || 'Cliente' }
          }
        });
        if (error) {
            if (error.message.includes('already registered')) {
                this.showToast('Este e-mail jÃ¡ possui conta. Tente recuperar a senha.', 'info');
            } else {
                throw error;
            }
            return false;
        }
        
        this.showToast('Cadastro realizado! Verifique seu e-mail para confirmar.', 'success');
        return true;
      } catch (e: any) {
        this.showToast('Erro no cadastro: ' + e.message, 'error');
        return false;
      }
    } else {
      return this.login(email, password);
    }
  }

  async recoverPassword(email: string) {
     if (this.mode() === 'real') {
       if (!email) {
         this.showToast('Digite seu e-mail.', 'error');
         return false;
       }
       try {
         const { error } = await this.supabase.supabase.auth.resetPasswordForEmail(email, {
           redirectTo: globalThis.location.origin + '/minha-conta/update-password',
         });
         if (error) throw error;
         this.showToast('E-mail de recuperaÃ§Ã£o enviado!', 'success');
         return true;
       } catch(e: any) {
         this.showToast('Erro: ' + e.message, 'error');
         return false;
       }
     } else {
       this.showToast('SimulaÃ§Ã£o: E-mail de recuperaÃ§Ã£o enviado.', 'success');
       return true;
     }
  }

  async loginWithOtp(contact: string, type: 'sms' | 'email') {
      if(this.mode() === 'real') {
          try {
              if (type === 'sms') {
                  const { error } = await this.supabase.supabase.auth.signInWithOtp({
                      phone: contact,
                      options: { shouldCreateUser: true }
                  });
                  if(error) throw error;
              } else {
                  const { error } = await this.supabase.supabase.auth.signInWithOtp({
                      email: contact,
                      options: { shouldCreateUser: true }
                  });
                  if(error) throw error;
              }
              
              this.showToast(`CÃ³digo enviado para seu ${type === 'sms' ? 'celular' : 'e-mail'}!`, 'success');
              return true;
          } catch(e: any) {
              this.showToast('Erro ao enviar cÃ³digo: ' + e.message, 'error');
              return false;
          }
      } else {
          this.showToast(`CÃ³digo 123456 enviado para ${contact} (Visual)`, 'success');
          return true;
      }
  }
  async verifyOtp(contact: string, token: string, type: 'sms' | 'email') {
    if (this.mode() === 'real') {
      return this.verifyOtpReal(contact, token, type);
    }
    return this.verifyOtpVisual(contact, token, type);
  }

  private async verifyOtpReal(contact: string, token: string, type: 'sms' | 'email'): Promise<boolean> {
    try {
      if (type === 'sms') {
        const { error } = await this.supabase.supabase.auth.verifyOtp({
          token,
          type: 'sms',
          phone: contact
        });
        if (error) throw error;
      } else {
        const { error } = await this.supabase.supabase.auth.verifyOtp({
          token,
          type: 'email',
          email: contact
        });
        if (error) throw error;
      }
      return true;
    } catch (e: any) {
      console.error('Erro ao verificar OTP', e);
      this.showToast('Código inválido ou expirado.', 'error');
      return false;
    }
  }

  private verifyOtpVisual(contact: string, token: string, type: 'sms' | 'email'): boolean {
    if (token !== '123456') {
      this.showToast('Código incorreto (Use 123456)', 'error');
      return false;
    }

    const newUser: User = {
      id: 'u-otp-' + Date.now(),
      name: 'Cliente ' + type.toUpperCase(),
      email: type === 'email' ? contact : undefined,
      phone: type === 'sms' ? contact : undefined,
      role: 'customer'
    };

    this.user.set(newUser);
    this.showToast('Autenticado com sucesso!', 'success');
    return true;
  }

  logout() {
    if (this.mode() === 'real') {
        if (this.user()?.id) {
          this.notifications.deactivateUserSubscriptions(this.user()!.id);
        }
        this.supabase.supabase.auth.signOut();
    }
    this.user.set(null);
    localStorage.removeItem('admin_token');
    this.showToast('VocÃª saiu da conta', 'info');
  }

  async addProduct(product: Product) {
    this.products.update(p => [...p, product]);
    if (this.mode() === 'real') {
       try { await this.supabase.insert('products', product); } catch(e) { console.error(e); }
    }
    this.showToast('Produto cadastrado!', 'success');
  }

  async updateProduct(product: Product) {
    const previous = this.products().find(prod => prod.id === product.id);
    this.products.update(p => p.map(prod => prod.id === product.id ? product : prod));
    if (this.mode() === 'real') {
        try { await this.supabase.update('products', product.id, product); } catch(e) { console.error(e); }
        if ((previous?.stock || 0) <= 0 && (product.stock || 0) > 0) {
          this.notifications.queueEvent('product_restocked', {
            productId: product.id,
            productName: product.name,
            stock: product.stock
          }, this.user()?.id);
        }
    }
    this.showToast('Produto atualizado!', 'success');
  }

  async deleteProduct(id: string) {
    this.products.update(p => p.filter(prod => prod.id !== id));
    if (this.mode() === 'real') {
      try {
        await this.supabase.delete('products', id);
      } catch (e) {
        console.error('Erro ao remover produto no servidor', e);
        this.showToast('Erro ao remover no servidor', 'error');
      }
    }
    this.showToast('Produto removido.', 'info');
  }

  addCategory(c: Category) {
    this.categories.update(l => [...l, c]);
    if (this.mode() === 'real') {
      this.supabase.insert('categories', c);
    }
  }

  updateCategory(c: Category) {
    this.categories.update(l => l.map(i => i.id === c.id ? c : i));
    if (this.mode() === 'real') {
      this.supabase.update('categories', c.id, c);
    }
  }

  deleteCategory(id: string) {
    this.categories.update(l => l.filter(i => i.id !== id));
    if (this.mode() === 'real') {
      this.supabase.delete('categories', id);
    }
  }

  addBanner(b: Banner) {
    this.banners.update(l => [...l, b]);
  }

  updateBanner(b: Banner) {
    this.banners.update(l => l.map(i => i.id === b.id ? b : i));
  }

  deleteBanner(id: string) {
    this.banners.update(l => l.filter(i => i.id !== id));
  }

  addCoupon(c: Coupon) {
    this.coupons.update(l => [...l, c]);
    if (this.mode() === 'real') {
      this.notifications.queueEvent('promotion_created', {
        code: c.code,
        description: c.description || '',
        value: c.value,
        type: c.type
      }, this.user()?.id);
    }
  }

  deleteCoupon(id: string) {
    this.coupons.update(l => l.filter(i => i.id !== id));
  }

  showToast(message: string, type: 'success' | 'error' | 'info' = 'info') {
    const id = Date.now();
    this.toasts.update(t => [...t, { message, type, id }]);
    setTimeout(() => {
      this.toasts.update(t => t.filter(toast => toast.id !== id));
    }, 3000);
  }

  toggleCart(open: boolean) {
    this.isCartOpen.set(open);
    document.body.style.overflow = open ? 'hidden' : '';
  }

  closeWelcomePopup() {
    this.showWelcomePopup.set(false);
    localStorage.setItem('yarakids_popup_seen', 'true');
  }

  toggleFavorite(productId: string) {
    if (this.favorites().includes(productId)) {
      this.favorites.update(f => f.filter(id => id !== productId));
      this.showToast('Removido dos favoritos', 'info');
      return;
    }

    this.favorites.update(f => [...f, productId]);
    this.showToast('Adicionado aos favoritos!', 'success');
  }

  isFavorite(productId: string) {
    return this.favorites().includes(productId);
  }

  getVariantStock(product: Product, size: string, color: string): number {
    if (product.variants?.length) {
      const variant = product.variants.find(v => v.size === size && v.color === color);
      return variant ? variant.stock : 0;
    }
    return product.stock;
  }

  addToCart(product: Product, size: string, color: string) {
    const currentCart = this.cart();
    const existingItem = currentCart.find(i => i.id === product.id && i.selectedSize === size && i.selectedColor === color);
    const quantityInCart = existingItem ? existingItem.quantity : 0;
    const availableStock = this.getVariantStock(product, size, color);

    if (quantityInCart + 1 > availableStock) {
      this.showToast(`Estoque insuficiente! Apenas ${availableStock} disponiveis nesta combinacao.`, 'error');
      return;
    }

    this.cart.update(current => {
      if (existingItem) {
        this.showToast('Quantidade atualizada na sacola', 'success');
        this.toggleCart(true);
        return current.map(i => i === existingItem ? { ...i, quantity: i.quantity + 1 } : i);
      }

      this.showToast('Produto adicionado a sacola!', 'success');
      this.toggleCart(true);
      return [...current, { ...product, selectedSize: size, selectedColor: color, quantity: 1 }];
    });
  }

  removeFromCart(itemId: string, size: string, color: string) {
    this.cart.update(current => current.filter(i => !(i.id === itemId && i.selectedSize === size && i.selectedColor === color)));
    this.showToast('Produto removido', 'info');
  }

  updateQuantity(itemId: string, size: string, color: string, delta: number) {
    const product = this.products().find(p => p.id === itemId);
    if (!product) return;

    this.cart.update(current => current.map(item => {
      if (item.id !== itemId || item.selectedSize !== size || item.selectedColor !== color) {
        return item;
      }

      const newQty = item.quantity + delta;
      const maxStock = this.getVariantStock(product, size, color);
      if (delta > 0 && newQty > maxStock) {
        this.showToast(`Limite de estoque atingido! (${maxStock})`, 'error');
        return item;
      }
      if (newQty < 1) return item;

      return { ...item, quantity: newQty };
    }));
  }

  clearCart() {
    this.cart.set([]);
    this.appliedCoupon.set(null);
    this.isGiftWrapped.set(false);
  }

  validateCoupon(code: string) {
    const coupon = this.coupons().find(c => c.code === code && c.active);
    if (!coupon) {
      return { valid: false, discount: 0, message: 'Cupom invalido' };
    }
    if (this.cartTotal() < coupon.minPurchase) {
      return { valid: false, discount: 0, message: `Minimo de R$ ${coupon.minPurchase} para este cupom` };
    }

    let discount = 0;
    if (coupon.type === 'percent') {
      discount = this.cartTotal() * (coupon.value / 100);
    } else if (coupon.type === 'fixed') {
      discount = coupon.value;
    }

    return { valid: true, discount, message: 'Cupom aplicado com sucesso!' };
  }

  applyCoupon(code: string) {
    const res = this.validateCoupon(code);
    if (res.valid) {
      const coupon = this.coupons().find(c => c.code === code);
      this.appliedCoupon.set(coupon || null);
      this.showToast(res.message, 'success');
      return;
    }

    this.showToast(res.message, 'error');
  }

  removeCoupon() {
    this.appliedCoupon.set(null);
    this.showToast('Cupom removido', 'info');
  }

  addToRecent(product: Product) {
    const current = this.recentProducts();
    const filtered = current.filter(p => p.id !== product.id);
    const updated = [product, ...filtered].slice(0, 10);
    this.recentProducts.set(updated);
    localStorage.setItem('yarakids_recent', JSON.stringify(updated));
  }

  updateOrderStatus(orderId: string, status: Order['status']) {
    this.orders.update(orders => orders.map(o => o.id === orderId ? { ...o, status } : o));
    if (this.mode() === 'real') {
      this.supabase.update('orders', orderId, { status });
      this.notifications.queueEvent('order_status_changed', { orderId, status }, this.user()?.id);
    }
    this.showToast(`Status do pedido #${orderId} atualizado.`, 'success');
  }

  getReviews(productId: string): Review[] {
    return this.reviews().filter(r => r.productId === productId);
  }

  canReview(productId: string): boolean {
    const currentUser = this.user();
    if (!currentUser) return false;

    return this.orders().some(order =>
      order.userEmail === currentUser.email &&
      (order.status === 'paid' || order.status === 'delivered' || order.status === 'shipped') &&
      order.items.some(item => item.id === productId)
    );
  }

  addReview(productId: string, rating: number, comment: string) {
    const currentUser = this.user();
    if (!currentUser) {
      this.showToast('Faca login para avaliar', 'error');
      return;
    }

    const newReview: Review = {
      id: 'rev-' + Date.now(),
      productId,
      user: currentUser.name,
      date: new Date().toLocaleDateString(),
      rating,
      comment
    };

    this.reviews.update(r => [newReview, ...r]);
    this.products.update(prods => prods.map(p => {
      if (p.id !== productId) return p;
      const prodReviews = this.reviews().filter(r => r.productId === productId);
      const avg = prodReviews.reduce((sum, r) => sum + r.rating, 0) / prodReviews.length;
      return { ...p, rating: avg, reviews: prodReviews.length };
    }));

    this.showToast('Obrigado pela sua avaliacao!', 'success');
  }
}


